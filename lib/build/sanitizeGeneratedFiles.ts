// lib/build/sanitizeGeneratedFiles.ts

import type { BuildPayload } from './types';

export function sanitizeGeneratedFiles(
  files: { path: string; content: string }[],
  payload: Pick<BuildPayload, 'ideaId'>
): { path: string; content: string }[] {
  const sanitized: { path: string; content: string }[] = [];

  // --- Handle frontend files
  const frontendChunks = files.filter((f) => f.path.startsWith('frontend/'));
  for (const chunk of frontendChunks) {
    const content = chunk.content.trim();

    if (content.startsWith('<!DOCTYPE html') || content.startsWith('<html')) {
      sanitized.push({ path: 'public/index.html', content });
    } else if (content.includes('tailwind') || content.includes('{') || content.includes('color')) {
      sanitized.push({ path: 'public/styles.css', content });
    } else if (content.includes('addEventListener') || content.includes('window.') || content.includes('document.')) {
      sanitized.push({ path: 'public/app.js', content });
    } else {
      console.warn('⚠️ Could not classify frontend chunk:', chunk.path);
    }
  }

  // --- Handle backend files
  const backendChunks = files.filter((f) => f.path.startsWith('backend/'));
  const handlerSnippets: string[] = [];

  backendChunks.forEach((chunk, i) => {
    const fn = `const handler${i} = async (context) => {\n${chunk.content.trim()}\n}`;
    handlerSnippets.push(fn);
  });

  if (handlerSnippets.length === 0) {
    // fallback backend
    handlerSnippets.push(`const fallback = async (context) => {
  return new Response("Backend is empty", {
    headers: { "Content-Type": "text/plain" }
  });
};`);
  }

  const routerBody =
    handlerSnippets.length > 1
      ? handlerSnippets
          .map((_, i) => `  if (url.pathname.includes("route${i}")) return handler${i}(context);`)
          .join('\n')
      : handlerSnippets[0].includes('fallback')
      ? `  return fallback(context);`
      : `  return handler0(context);`;

  const backendFile = `// Auto-generated by sanitizeGeneratedFiles
${handlerSnippets.join('\n\n')}

export async function onRequest(context) {
  const url = new URL(context.request.url);
${routerBody}
}
`;

  sanitized.push({
    path: 'functions/index.ts',
    content: backendFile,
  });

  // --- Pass through other non-txt files
  for (const f of files) {
    if (
      !f.path.endsWith('.txt') &&
      f.path !== 'functions/index.ts' && // already replaced
      f.path !== 'frontend/index.ts' &&
      f.path !== 'backend/index.ts'
    ) {
      sanitized.push(f);
    }
  }

  return sanitized;
}