// lib/build/sanitizeGeneratedFiles.ts
import type { BuildPayload } from './types';

type File = { path: string; content: string };

export function sanitizeGeneratedFiles(
  files: File[],
  payload: Pick<BuildPayload, 'ideaId'>
): File[] {
  const sanitized: File[] = [];
  const publicFiles: File[] = [];
  const backendChunks: File[] = [];

  for (const file of files) {
    const { path, content } = file;

    // Extract frontend files
    if (path.startsWith('frontend/')) {
      const lowered = content.toLowerCase();
      let outPath = '';

      if (lowered.includes('<html')) outPath = 'public/index.html';
      else if (lowered.includes('tailwind') || lowered.includes('body {')) outPath = 'public/styles.css';
      else if (lowered.includes('function') || lowered.includes('addEventListener')) outPath = 'public/app.js';

      if (outPath) publicFiles.push({ path: outPath, content });
    }

    // Collect backend files
    else if (path.startsWith('backend/')) {
      backendChunks.push(file);
    }

    // Pass through all config/static assets
    else if (
      path === 'wrangler.toml' ||
      path === '.github/workflows/deploy.yml' ||
      path.startsWith('config/') ||
      path.startsWith('public/')
    ) {
      sanitized.push({ path, content });
    }
  }

  sanitized.push(...publicFiles);

  if (backendChunks.length > 0) {
    const handlerSnippets = backendChunks.map((file, i) => {
      return `// From ${file.path}
const handler${i} = async (context) => {
${file.content.trim()}
};`;
    });

    const routerBody = backendChunks
      .map((_, i) => `  if (url.pathname.includes("route${i}")) return handler${i}(context);`)
      .join('\n') || '  return new Response("OK");';

    const router = `
export async function onRequest(context) {
  const url = new URL(context.request.url);
${routerBody}
}`;

    const finalContent = [
      '// Auto-generated by sanitizeGeneratedFiles',
      ...handlerSnippets,
      router,
    ].join('\n\n');

    sanitized.push({
      path: 'functions/index.ts',
      content: finalContent,
    });
  }

  return sanitized;
}