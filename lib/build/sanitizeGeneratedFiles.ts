// lib/build/sanitizeGeneratedFiles.ts

import type { BuildPayload } from './types';

interface File {
  path: string;
  content: string;
}

function inferFrontendFiles(frontendChunks: File[]): File[] {
  const files: File[] = [];

  for (const chunk of frontendChunks) {
    const trimmed = chunk.content.trim();

    if (trimmed.startsWith('<!DOCTYPE html') || trimmed.startsWith('<html')) {
      files.push({ path: 'public/index.html', content: chunk.content });
    } else if (trimmed.startsWith('body') || trimmed.includes('{') && trimmed.includes('}')) {
      files.push({ path: 'public/styles.css', content: chunk.content });
    } else if (trimmed.includes('addEventListener') || trimmed.includes('function') || trimmed.includes('console.')) {
      files.push({ path: 'public/app.js', content: chunk.content });
    } else {
      files.push({ path: `public/unknown-${Date.now()}.txt`, content: chunk.content });
    }
  }

  return files;
}

function cleanBackendChunk(content: string): string {
  return content
    .split('\n')
    .filter(line => {
      const trimmed = line.trim();
      if (!trimmed) return false;
      if (/^\d+[\.\)]/.test(trimmed)) return false; // numbered markdown
      if (/^#+ /.test(trimmed)) return false; // markdown heading
      if (/^\*\*/.test(trimmed)) return false; // markdown bold
      if (/^\/\/\s*[\*\-]/.test(trimmed)) return false; // comment bullets
      if (/^\*\s+/.test(trimmed)) return false; // list
      if (/^[A-Z][a-z]+\:/.test(trimmed)) return false; // label-like text
      return true;
    })
    .join('\n');
}

export function sanitizeGeneratedFiles(
  files: File[],
  context: Pick<BuildPayload, 'ideaId'>
): File[] {
  const sanitized: File[] = [];

  const frontendChunks = files.filter(f => f.path.startsWith('frontend/'));
  const backendChunks = files.filter(f => f.path.startsWith('backend/'));
  const otherFiles = files.filter(f => !f.path.startsWith('frontend/') && !f.path.startsWith('backend/'));

  // ✅ 1. Infer public files from frontend chunks
  const publicFiles = inferFrontendFiles(frontendChunks);
  sanitized.push(...publicFiles);

  // ✅ 2. Merge backend chunks into functions/index.ts
  if (backendChunks.length) {
    const handlers = backendChunks.map((chunk, i) => {
      const body = cleanBackendChunk(chunk.content);
      return `const handler${i} = async (context) => {\n${body}\n}`;
    });

    const router = `
export async function onRequest(context) {
  const url = new URL(context.request.url);
  ${backendChunks.map((_, i) => `if (url.pathname.includes("route${i}")) return handler${i}(context);`).join('\n  ')}
}
`.trim();

    const mergedBackend = `// Auto-generated by sanitizeGeneratedFiles\n\n${handlers.join('\n\n')}\n\n${router}\n`;
    sanitized.push({
      path: 'functions/index.ts',
      content: mergedBackend,
    });
  }

  // ✅ 3. Keep only non-chunk files
  const passthrough = otherFiles.filter(f => !f.path.includes('chunk_'));
  sanitized.push(...passthrough);

  return sanitized;
}