// lib/build/sanitizeGeneratedFiles.ts
import type { BuildPayload } from './types';

/**
 * Normalizes and rewrites the file paths of agent-generated files to match
 * expected Worker deployment structure. Transforms frontend chunks into HTML/CSS/JS
 * and merges backend chunks into functions/index.ts.
 */
export function sanitizeGeneratedFiles(
  files: { path: string; content: string }[],
  context: { ideaId: string }
): { path: string; content: string }[] {
  const sanitized: { path: string; content: string }[] = [];

  // --- 1. Transform frontend chunks ---
  const frontendChunks = files.filter(f => f.path.startsWith('frontend/'));
  const inferredFrontendFiles = inferFrontendFiles(frontendChunks);
  sanitized.push(...inferredFrontendFiles);

  // --- 2. Merge backend chunks ---
  const backendChunks = files.filter(f => f.path.startsWith('backend/'));
  const mergedBackend = mergeBackendChunks(backendChunks);
  if (mergedBackend) {
    sanitized.push({
      path: 'functions/index.ts',
      content: mergedBackend,
    });
  }

  // --- 3. Include config and other relevant files ---
  for (const file of files) {
    if (file.path.endsWith('.txt')) continue; // skip unprocessed chunks
    if (file.path.startsWith('config/') || file.path.endsWith('.json')) {
      sanitized.push(file);
    }
  }

  return sanitized;
}

function inferFrontendFiles(
  chunks: { path: string; content: string }[]
): { path: string; content: string }[] {
  return chunks.map((chunk, i) => {
    const lower = chunk.content.toLowerCase();
    let ext = 'txt';

    if (lower.includes('<html')) ext = 'html';
    else if (lower.includes('body {') || lower.includes('color:')) ext = 'css';
    else if (lower.includes('function') || lower.includes('const')) ext = 'js';

    return {
      path: `public/${inferNameFromContent(chunk.content, ext, i)}`,
      content: chunk.content,
    };
  });
}

function inferNameFromContent(content: string, ext: string, index: number): string {
  if (ext === 'html') return 'index.html';
  if (ext === 'css') return 'styles.css';
  if (ext === 'js') return 'app.js';
  return `chunk_${index}.${ext}`;
}

function mergeBackendChunks(
  chunks: { path: string; content: string }[]
): string | null {
  const cleaned = chunks.map((chunk, i) => {
    const body = cleanBackendChunk(chunk.content);
    return `const handler${i} = async (context) => {\n${body}\n};`;
  });

  if (cleaned.length === 0) return null;

  const router = `
export async function onRequest(context) {
  const url = new URL(context.request.url);
  ${cleaned.map((_, i) => `if (url.pathname.includes("route${i}")) return handler${i}(context);`).join('\n  ')}
}
`;

  return `// Auto-generated by sanitizeGeneratedFiles\n\n${cleaned.join('\n\n')}\n${router}`;
}

function cleanBackendChunk(content: string): string {
  return content
    .split('\n')
    .filter(line => {
      const trimmed = line.trim();
      if (!trimmed) return false;
      if (/^\d+[\.\)]/.test(trimmed)) return false;
      if (/^#+ /.test(trimmed)) return false;
      if (/^\*\*/.test(trimmed)) return false;
      if (/^\/\/\s*[\*\-]/.test(trimmed)) return false;
      if (/^\*\s+/.test(trimmed)) return false;
      if (/^[A-Z][a-z\s]+\.$/.test(trimmed)) return false;
      if (/^This (function|handler|module)/i.test(trimmed)) return false;
      return true;
    })
    .join('\n');
}