// lib/build/sanitizeGeneratedFiles.ts
import type { BuildPayload } from './types';

type FileSpec = { path: string; content: string };

/**
 * Normalizes and rewrites the file paths of agent-generated files to match
 * what Cloudflare Workers expects: `functions/index.ts`, `public/index.html`, etc.
 */
export function sanitizeGeneratedFiles(
  files: FileSpec[],
  meta: Pick<BuildPayload, 'ideaId'>
): FileSpec[] {
  const sanitized: FileSpec[] = [];

  const frontendChunks = files.filter(f => f.path.startsWith('frontend/'));
  const backendChunks = files.filter(f => f.path.startsWith('backend/'));

  // --- Infer frontend assets from chunk content ---
  frontendChunks.forEach((chunk, i) => {
    const content = chunk.content.trim();
    if (content.includes('<html')) {
      sanitized.push({ path: 'public/index.html', content });
    } else if (content.includes('body {') || content.includes('tailwind')) {
      sanitized.push({ path: 'public/styles.css', content });
    } else if (content.includes('addEventListener') || content.includes('DOMContentLoaded')) {
      sanitized.push({ path: 'public/app.js', content });
    } else {
      sanitized.push({ path: `public/chunk_${i}.txt`, content }); // fallback
    }
  });

  // --- Merge backend chunks into functions/index.ts ---
  const backendHandlers: string[] = [];
  backendChunks.forEach((chunk, i) => {
    const cleaned = chunk.content
      .split('\n')
      .map(line => line.trim())
      .filter(line => {
        return (
          line &&
          !/^#+ /.test(line) &&         // Markdown headers like ## Title
          !/^\d+[\.\)] /.test(line) &&  // Numbered lines like 1. or 2)
          !/^[-*] /.test(line) &&       // Bullet points
          !/^\*\*/.test(line) &&        // Bold-only lines
          !/^\/\/ From /.test(line) &&  // GPT-style comments
          !/^\/\/ Auto-generated/.test(line) &&
          !/^["']use strict["']/.test(line) &&
          !/^[A-Z][a-z]+: /.test(line)  // "Description: ..." style
        );
      })
      .join('\n')
      .trim();

    if (cleaned) {
      backendHandlers.push(`const handler${i} = async (context) => {\n${cleaned}\n};`);
    }
  });

  if (backendHandlers.length > 0) {
    const routingLogic = backendHandlers
      .map((_, i) => `  if (url.pathname.includes("route${i}")) return handler${i}(context);`)
      .join('\n');

    const backendCode = `// Auto-generated by sanitizeGeneratedFiles
${backendHandlers.join('\n\n')}

export async function onRequest(context) {
  const url = new URL(context.request.url);
${routingLogic}
}
`;

    sanitized.push({
      path: 'functions/index.ts',
      content: backendCode,
    });
  }

  // --- Preserve config and asset files ---
  files.forEach(file => {
    if (
      file.path.startsWith('config/') ||
      file.path === 'wrangler.toml' ||
      file.path === '.github/workflows/deploy.yml' ||
      file.path === 'package.json' ||
      file.path === 'public/manifest.json' ||
      file.path === 'public/browserconfig.xml'
    ) {
      sanitized.push(file);
    }
  });

  return sanitized;
}