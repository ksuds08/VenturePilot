// lib/build/sanitizeGeneratedFiles.ts

import type { BuildPayload } from './types';

interface FileSpec {
  path: string;
  content: string;
}

/**
 * Sanitizes and transforms agent-generated files into final deployable structure.
 */
export function sanitizeGeneratedFiles(
  files: FileSpec[],
  payload: Pick<BuildPayload, 'ideaId'>
): FileSpec[] {
  const sanitized: FileSpec[] = [];

  // ⬅️ Frontend: Convert frontend/chunk_X.txt → public/index.html, styles.css, app.js
  const frontendChunks = files.filter(f => f.path.startsWith('frontend/'));
  const inferredFrontend = inferFrontendFiles(frontendChunks);
  sanitized.push(...inferredFrontend);

  // ⬅️ Backend: Merge backend/chunk_X.txt → functions/index.ts
  const backendChunks = files.filter(f => f.path.startsWith('backend/'));
  const backendHandler = mergeBackendChunks(backendChunks);
  if (backendHandler) {
    sanitized.push({
      path: 'functions/index.ts',
      content: backendHandler,
    });
  }

  // ✅ Preserve remaining non-chunk files (e.g. config/wrangler.toml, assets)
  for (const file of files) {
    if (!file.path.endsWith('.txt')) {
      sanitized.push(file);
    }
  }

  return sanitized;
}

/**
 * Tries to infer public asset types from frontend chunk content.
 */
function inferFrontendFiles(chunks: FileSpec[]): FileSpec[] {
  return chunks.map((chunk, index) => {
    const content = chunk.content.trim();
    let filename = `chunk_${index}.txt`;

    if (content.startsWith('<!DOCTYPE html') || content.startsWith('<html')) {
      filename = 'index.html';
    } else if (content.includes('tailwind') || content.includes('{') && content.includes('}')) {
      filename = 'styles.css';
    } else if (content.includes('addEventListener') || content.includes('window.onload')) {
      filename = 'app.js';
    }

    return {
      path: `public/${filename}`,
      content,
    };
  });
}

/**
 * Merges backend chunks into a single Cloudflare Worker script.
 */
function mergeBackendChunks(chunks: FileSpec[]): string | null {
  if (chunks.length === 0) return null;

  const handlers: string[] = [];
  const exports: string[] = [];

  chunks.forEach((chunk, index) => {
    const name = `handler${index}`;
    let code = chunk.content.trim();

    code = code
      // Replace named exports with const handlers
      .replace(/export\s+async\s+function\s+onRequest\s*\(.*?\)/g, `const ${name} = async (context) =>`)
      .replace(/export\s+default\s+async\s+function\s+onRequest\s*\(.*?\)/g, `const ${name} = async (context) =>`);

    handlers.push(`// From ${chunk.path}\n${code}`);
    exports.push(`  ${name}`);
  });

  const merged = `// Auto-generated by sanitizeGeneratedFiles\n\n` +
    handlers.join('\n\n') +
    `\n\nexport default {\n${exports.join(',\n')}\n};`;

  return merged;
}